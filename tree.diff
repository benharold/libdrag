diff --git a/pkg/tree/tree.go b/pkg/tree/tree.go
index 88d8d88..9117bd2 100644
--- a/pkg/tree/tree.go
+++ b/pkg/tree/tree.go
@@ -3,6 +3,7 @@ package tree
 import (
 	"context"
 	"fmt"
+	"github.com/google/uuid"
 	"sync"
 	"time"
 
@@ -58,15 +59,16 @@ type ChristmasTree struct {
 }
 
 func NewChristmasTree() *ChristmasTree {
+	id := uuid.New().String()
 	return &ChristmasTree{
-		id: "christmas_tree",
+		id: id,
 		status: Status{
 			Armed:       false,
 			Activated:   false,
 			LightStates: make(map[int]map[LightType]LightState),
 		},
 		compStatus: component.ComponentStatus{
-			ID:       "christmas_tree",
+			ID:       id,
 			Status:   "stopped",
 			Metadata: make(map[string]interface{}),
 		},
diff --git a/pkg/tree/tree_test.go b/pkg/tree/tree_test.go
index 12f007b..5bd9a4c 100644
--- a/pkg/tree/tree_test.go
+++ b/pkg/tree/tree_test.go
@@ -2,10 +2,8 @@ package tree
 
 import (
 	"context"
-	"testing"
-	"time"
-
 	"github.com/benharold/libdrag/pkg/config"
+	"testing"
 )
 
 func TestNewChristmasTree(t *testing.T) {
@@ -16,10 +14,15 @@ func TestNewChristmasTree(t *testing.T) {
 
 	status := tree.GetTreeStatus()
 	if status.Armed {
-		t.Fatal("Auto-start should not be activated initially")
+		t.Fatal("Tree should not be armed initially")
 	}
 	if status.Activated {
-		t.Fatal("Tree should not be running initially")
+		t.Fatal("Tree should not be activated initially")
+	}
+
+	// Check the ID exists (remove hardcoded check)
+	if tree.GetID() == "" {
+		t.Fatal("Tree ID should not be empty")
 	}
 }
 
@@ -49,21 +52,35 @@ func TestChristmasTreeLightStates(t *testing.T) {
 	}
 
 	// Get initial tree status
-	treeStatus := tree.GetTreeStatus()
+	status := tree.GetTreeStatus()
 
 	// Verify light states are initialized
-	if treeStatus.LightStates == nil {
+	if status.LightStates == nil {
 		t.Fatal("LightStates should be initialized")
 	}
 
 	// Check that we have light states for at least one lane
-	if len(treeStatus.LightStates) == 0 {
+	if len(status.LightStates) == 0 {
 		t.Fatal("Should have light states for at least one lane")
 	}
+
+	// Make sure no staging lights are on
+	if status.LightStates[1][LightPreStage] != LightOff {
+		t.Fatal("Pre-stage light should be off for lane 1")
+	}
+	if status.LightStates[2][LightPreStage] != LightOff {
+		t.Fatal("Pre-stage light should be off for lane 2")
+	}
+	if status.LightStates[1][LightStage] != LightOff {
+		t.Fatal("Stage light should be off for lane 1")
+	}
+	if status.LightStates[2][LightStage] != LightOff {
+		t.Fatal("Stage light should be off for lane 1")
+	}
 }
 
 // Test Pre-Stage Light Logic using direct method calls
-func TestPreStageSequence(t *testing.T) {
+func TestPreStage(t *testing.T) {
 	tree := NewChristmasTree()
 	cfg := config.NewDefaultConfig()
 
@@ -82,36 +99,27 @@ func TestPreStageSequence(t *testing.T) {
 		t.Fatal("Pre-stage light should be on for lane 1")
 	}
 
-	// Tree should not be armed with only one lane pre-staged
-	if status.Armed {
-		t.Fatal("Auto-start should not be activated with only one lane pre-staged")
-	}
-
 	// Pre-stage lane 2
 	tree.SetPreStage(2)
+
+	// Verify pre-stage light is on for lane 2
+	if status.LightStates[2][LightPreStage] != LightOn {
+		t.Fatal("Pre-stage light should be on for lane 2")
+	}
 }
 
 // Test Stage Light Logic using direct method calls
-func TestStageSequence(t *testing.T) {
+func TestStage(t *testing.T) {
 	tree := NewChristmasTree()
 	cfg := config.NewDefaultConfig()
 
-	// Initialize and start
+	// Initialize
 	err := tree.Initialize(context.Background(), cfg)
 	if err != nil {
 		t.Fatalf("Initialize failed: %v", err)
 	}
 
-	err = tree.Arm(context.Background())
-	if err != nil {
-		t.Fatalf("Arm failed: %v", err)
-	}
-
-	// Pre-stage both lanes first
-	tree.SetPreStage(1)
-	tree.SetPreStage(2)
-
-	// Stage lane 1
+	// Stage both lanes
 	tree.SetStage(1)
 	tree.SetStage(2)
 
@@ -127,8 +135,8 @@ func TestStageSequence(t *testing.T) {
 	}
 }
 
-// Test Pro Tree Sequence Timing using direct method calls
-func TestProTreeSequence(t *testing.T) {
+// Test Tree Not Armed Error
+func TestTreeNotArmedError(t *testing.T) {
 	tree := NewChristmasTree()
 	cfg := config.NewDefaultConfig()
 
@@ -138,57 +146,308 @@ func TestProTreeSequence(t *testing.T) {
 		t.Fatalf("Initialize failed: %v", err)
 	}
 
-	// Pre-stage both lanes
+	// Try to start sequence without arming tree
+	err = tree.StartSequence(config.TreeSequencePro)
+	if err == nil {
+		t.Fatal("Expected error when starting sequence with unarmed tree")
+	}
+
+	if err.Error() != "tree is not armed" {
+		t.Fatalf("Expected 'tree is not armed' error, got: %v", err)
+	}
+}
+
+func TestChristmasTreeArm(t *testing.T) {
+	tree := NewChristmasTree()
+	cfg := config.NewDefaultConfig()
+
+	err := tree.Initialize(context.Background(), cfg)
+	if err != nil {
+		t.Fatalf("Initialize failed: %v", err)
+	}
+
+	// Verify tree is not armed initially
+	if tree.IsArmed() {
+		t.Fatal("Tree should not be armed initially")
+	}
+
+	// Arm the tree
+	err = tree.Arm(context.Background())
+	if err != nil {
+		t.Fatalf("Arm failed: %v", err)
+	}
+
+	// Verify tree is armed
+	if !tree.IsArmed() {
+		t.Fatal("Tree should be armed after calling Arm()")
+	}
+
+	// Verify component status
+	status := tree.GetStatus()
+	if status.Status != "armed" {
+		t.Fatalf("Expected component status 'armed', got '%s'", status.Status)
+	}
+
+	// Verify tree status
+	treeStatus := tree.GetTreeStatus()
+	if !treeStatus.Armed {
+		t.Fatal("Tree status should show armed")
+	}
+}
+
+func TestChristmasTreeActivate(t *testing.T) {
+	tree := NewChristmasTree()
+	cfg := config.NewDefaultConfig()
+
+	err := tree.Initialize(context.Background(), cfg)
+	if err != nil {
+		t.Fatalf("Initialize failed: %v", err)
+	}
+
+	// Verify tree is not activated initially
+	treeStatus := tree.GetTreeStatus()
+	if treeStatus.Activated {
+		t.Fatal("Tree should not be activated initially")
+	}
+
+	// Activate the tree
+	err = tree.Activate()
+	if err != nil {
+		t.Fatalf("Activate failed: %v", err)
+	}
+
+	// Verify tree is activated
+	treeStatus = tree.GetTreeStatus()
+	if !treeStatus.Activated {
+		t.Fatal("Tree should be activated after calling Activate()")
+	}
+
+	// Verify component status
+	status := tree.GetStatus()
+	if status.Status != "activated" {
+		t.Fatalf("Expected component status 'activated', got '%s'", status.Status)
+	}
+}
+
+func TestChristmasTreeArmAndActivate(t *testing.T) {
+	tree := NewChristmasTree()
+	cfg := config.NewDefaultConfig()
+
+	err := tree.Initialize(context.Background(), cfg)
+	if err != nil {
+		t.Fatalf("Initialize failed: %v", err)
+	}
+
+	// Arm then activate
+	err = tree.Arm(context.Background())
+	if err != nil {
+		t.Fatalf("Arm failed: %v", err)
+	}
+
+	err = tree.Activate()
+	if err != nil {
+		t.Fatalf("Activate failed: %v", err)
+	}
+
+	// Verify both states
+	treeStatus := tree.GetTreeStatus()
+	if !treeStatus.Armed {
+		t.Fatal("Tree should be armed")
+	}
+	if !treeStatus.Activated {
+		t.Fatal("Tree should be activated")
+	}
+
+	status := tree.GetStatus()
+	if status.Status != "activated" {
+		t.Fatalf("Expected component status 'activated', got '%s'", status.Status)
+	}
+}
+
+func TestNewChristmasTreeRandomID(t *testing.T) {
+	tree1 := NewChristmasTree()
+	tree2 := NewChristmasTree()
+
+	// Verify IDs are not empty
+	if tree1.GetID() == "" {
+		t.Fatal("Tree ID should not be empty")
+	}
+	if tree2.GetID() == "" {
+		t.Fatal("Tree ID should not be empty")
+	}
+
+	// Verify IDs are different (random)
+	if tree1.GetID() == tree2.GetID() {
+		t.Fatal("Tree IDs should be unique/random")
+	}
+
+	// Verify ID format (optional - adjust pattern as needed)
+	if len(tree1.GetID()) < 8 {
+		t.Fatal("Tree ID should be at least 8 characters")
+	}
+}
+
+func TestChristmasTreeEmergencyStop(t *testing.T) {
+	tree := NewChristmasTree()
+	cfg := config.NewDefaultConfig()
+
+	err := tree.Initialize(context.Background(), cfg)
+	if err != nil {
+		t.Fatalf("Initialize failed: %v", err)
+	}
+
+	// Arm and activate the tree first
+	err = tree.Arm(context.Background())
+	if err != nil {
+		t.Fatalf("Arm failed: %v", err)
+	}
+
+	err = tree.Activate()
+	if err != nil {
+		t.Fatalf("Activate failed: %v", err)
+	}
+
+	// Set some lights on to verify they get cleared
 	tree.SetPreStage(1)
-	tree.SetPreStage(2)
+	tree.SetStage(1)
 
-	// Arm Pro sequence
-	err = tree.StartSequence(config.TreeSequencePro)
+	// Verify initial state
+	treeStatus := tree.GetTreeStatus()
+	if !treeStatus.Armed {
+		t.Fatal("Tree should be armed before emergency stop")
+	}
+	if !treeStatus.Activated {
+		t.Fatal("Tree should be activated before emergency stop")
+	}
+
+	// Call emergency stop
+	err = tree.EmergencyStop()
 	if err != nil {
-		t.Fatalf("StartSequence failed: %v", err)
+		t.Fatalf("EmergencyStop failed: %v", err)
 	}
 
-	// Verify sequence is running
-	status := tree.GetTreeStatus()
-	if !status.Activated {
-		t.Fatal("Tree sequence should be running")
+	// Verify tree is disarmed and deactivated
+	treeStatus = tree.GetTreeStatus()
+	if treeStatus.Armed {
+		t.Fatal("Tree should not be armed after emergency stop")
+	}
+	if treeStatus.Activated {
+		t.Fatal("Tree should not be activated after emergency stop")
 	}
 
-	if status.SequenceType != config.TreeSequencePro {
-		t.Fatalf("Expected Pro sequence, got %v", status.SequenceType)
+	// Verify component status
+	status := tree.GetStatus()
+	if status.Status != "emergency_stopped" {
+		t.Fatalf("Expected component status 'emergency_stopped', got '%s'", status.Status)
 	}
 
-	// Wait for sequence to complete (green delay is 400ms for pro tree)
-	time.Sleep(500 * time.Millisecond)
+	// Verify all lights are off except red lights should be blinking
+	for lane := 1; lane <= cfg.Track().LaneCount; lane++ {
+		for _, lightType := range []LightType{LightPreStage, LightStage, LightAmber1, LightAmber2, LightAmber3, LightGreen} {
+			if treeStatus.LightStates[lane][lightType] != LightOff {
+				t.Fatalf("Light %s for lane %d should be off after emergency stop", lightType, lane)
+			}
+		}
+
+		// Red lights should be blinking
+		if treeStatus.LightStates[lane][LightRed] != LightBlink {
+			t.Fatalf("Red light for lane %d should be blinking after emergency stop", lane)
+		}
+	}
+}
 
-	// Verify green light is on
-	status = tree.GetTreeStatus()
-	if status.LightStates[1][LightGreen] != LightOn {
-		t.Fatal("Green light should be on after Pro sequence")
+func TestChristmasTreeAllStaged(t *testing.T) {
+	tree := NewChristmasTree()
+	cfg := config.NewDefaultConfig()
+
+	err := tree.Initialize(context.Background(), cfg)
+	if err != nil {
+		t.Fatalf("Initialize failed: %v", err)
+	}
+
+	// Initially should not be all staged (tree not armed)
+	if tree.AllStaged() {
+		t.Fatal("Tree should not be all staged initially")
+	}
+
+	// Arm the tree
+	err = tree.Arm(context.Background())
+	if err != nil {
+		t.Fatalf("Arm failed: %v", err)
 	}
-	if status.LightStates[2][LightGreen] != LightOn {
-		t.Fatal("Green light should be on for both lanes after Pro sequence")
+
+	// Still not all staged (no lanes staged yet)
+	if tree.AllStaged() {
+		t.Fatal("Tree should not be all staged when no lanes are staged")
+	}
+
+	// Stage only lane 1
+	tree.SetStage(1)
+	if tree.AllStaged() {
+		t.Fatal("Tree should not be all staged when only lane 1 is staged")
+	}
+
+	// Stage lane 2 as well (assuming 2-lane track from config)
+	tree.SetStage(2)
+	if !tree.AllStaged() {
+		t.Fatal("Tree should be all staged when both lanes are staged")
+	}
+
+	// Verify with unarmed tree (should return false even with all lanes staged)
+	tree.DisarmTree()
+	if tree.AllStaged() {
+		t.Fatal("Tree should not be all staged when disarmed, even with lanes staged")
 	}
 }
 
-// Test Tree Not Armed Error
-func TestTreeNotArmedError(t *testing.T) {
+func TestChristmasTreeDisarmTree(t *testing.T) {
 	tree := NewChristmasTree()
 	cfg := config.NewDefaultConfig()
 
-	// Initialize
 	err := tree.Initialize(context.Background(), cfg)
 	if err != nil {
 		t.Fatalf("Initialize failed: %v", err)
 	}
 
-	// Try to start sequence without arming tree
-	err = tree.StartSequence(config.TreeSequencePro)
-	if err == nil {
-		t.Fatal("Expected error when starting sequence with unarmed tree")
+	// Test disarming when not armed (edge case)
+	initialStatus := tree.GetTreeStatus()
+	if initialStatus.Armed {
+		t.Fatal("Tree should not be armed initially")
 	}
 
-	if err.Error() != "tree is not armed" {
-		t.Fatalf("Expected 'tree is not armed' error, got: %v", err)
+	// Call DisarmTree when already not armed (should be safe)
+	tree.DisarmTree()
+
+	// Verify state remains unchanged
+	status := tree.GetTreeStatus()
+	if status.Armed {
+		t.Fatal("Tree should still not be armed after calling DisarmTree on unarmed tree")
+	}
+	if status.ArmingSource != "" {
+		t.Fatal("ArmingSource should remain empty when disarming unarmed tree")
+	}
+
+	// Now arm the tree and test normal disarm
+	err = tree.Arm(context.Background())
+	if err != nil {
+		t.Fatalf("Arm failed: %v", err)
+	}
+
+	// Verify tree is armed
+	status = tree.GetTreeStatus()
+	if !status.Armed {
+		t.Fatal("Tree should be armed after calling Arm()")
+	}
+
+	// Test normal disarm
+	tree.DisarmTree()
+
+	// Verify tree is disarmed
+	status = tree.GetTreeStatus()
+	if status.Armed {
+		t.Fatal("Tree should not be armed after calling DisarmTree()")
+	}
+	if status.ArmingSource != "" {
+		t.Fatal("ArmingSource should be cleared after disarming")
 	}
 }
